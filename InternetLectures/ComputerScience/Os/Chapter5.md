# 가상 메모리

가상메모리도 중요하구나!!!

> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음   

예: 리눅스는 하나의 프로세스가 4GB임   
멀티 프로세스 몇개 띄우면 메모리 터짐, 멀티 스레드로 실행하거나 해야함

> 폰 노이만 구조 기반이므로, 폰 노이만 구조의 핵심은 코드는 메모리에 반드시 있어야 한다


메모리 용량이 부족해지기 때문에 위 기술이 등장   

* 가상 메모리: 메모리가 실제 메모리보다 많아 보이게 하는 기술
  * 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  * 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음

<img src="https://user-images.githubusercontent.com/72545732/143040986-2a08067e-988f-4a47-b8eb-cd5ef0870e8e.png">

자 그림을 보자 프로세스가 4기가 차지하는데 이것도 커널과 사용자 모드로 나뉘고 커널 모드중 일부만 메모리를 사용하고 있다.

<hr>

* 가상 메모리 기본 아이디어
  * 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다.
  * virtual address(가상 주소): 프로세스가 참조하는 주소 (0~4gb 정도의 주소를 할당 일부만 실제 메모리 주소를 가리킴)
  * physical address(물리 주소): 실제 메모리 주소
* MMU(Memory Management Unit) (하드웨어)
  * cpu에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

<hr>

* cpu는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
  * 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도의 장치를 둠
<img src="https://user-images.githubusercontent.com/72545732/143042306-0a6a9360-350e-413c-a0e4-88dc8f22f864.png">

* 프로세스 생성시, 페이지 테이블 정보 생성
  * PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
  * 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  * CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서, 물리 주소를 가져옴

### 페이징 시스템
* 페이징개념
  * 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
  * 하드웨어 지원이 필요
  * 리눅스에서는 4KB로 paging (4gb를 4kb로 다 쪼개고 번호를 붙여서 물리메모리에 넣고 빼고 하는거)
  * 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

<img src="https://user-images.githubusercontent.com/72545732/143044883-100fffdc-ebec-4cd0-a9a6-fb5241100ae3.png">