# 스케줄링 알고리즘 기본

스케쥴러 -> 프로세스 관리

목표 :
  * 시분할 시스템: 프로세스 응답시간을 가능한 짧게
  * 멀티 프로그래밍: cpu 사용률을 최대한 높게

#### FIFO 알고리즘
* first in first out

#### 최단 작업 우선 스케쥴러
* SJF(shorted Job First) 스케줄러

#### 우선순위 기반 스케쥴
* priority based
  * 정적 우선순위(우선순위를 미리 지정)
  * 동적 우선순위(스케쥴러가 상황에 따라 우선순위를 동적으로 변경)

#### Round Robin 스케쥴러
* 프로세스 p1을 실행하다가 프로세스가 끝나지 않아도 큐의 맨 마지막으로 옮기고 다음 프로세스를 실행
* 시분할 시스템 기반

#### 쉬어가기
* RealTime OS(RTOS): 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
  * 정확하게 프로그램 시작, 완료 시간을 보장, (공장, 공정)
* General Purpose OS(GPOS):
  * 프로세스 실행시간에 민감 x, 일반적인 목적으로 사용되는 OS(window, macos, unix)

#### 멀티프로그래밍과 Wait
* 멀티프로그래밍: cpu 사용률을 극대로 하는 알고리즘
* wait: 저장매체로부터 파일 읽기를 기다리는 시간으로 가정

<img src="https://user-images.githubusercontent.com/72545732/142706024-633fad99-e291-4f7f-bc27-b7324c947d9f.png">

#### 프로세스 상태
* Running
* Ready
* Block: 특정 이벤트 발생 대기 상태
런레복

#### 프로세스 상태와 스케쥴링
* 프로세스들의 상태중 복수개가 ready면 어떤걸 실행해야 할까?
* state 별로 queue를 만들어서 가지고 있자!!!!

<img src="https://user-images.githubusercontent.com/72545732/142707209-afd39197-a7a6-404b-a867-d6997266075a.png">



# 선점형과 비선점형 스케쥴러
* 선점형 스케쥴러
  * 하나의 프로세스가 다른 프로세스 대신에 cpu를 차지할 수 있음 => cpu를 가로챌수 있는거네??, 시분할 시스템을 이용하려면 선점형 스케쥴러가 기본적으로 되어야 한다.
* 비선점형 스케쥴러
  * 하나의 프로세스가 끝나지 않으면 다른 프로세스는 cpu를 차지할 수 없음 => 에티켓 지켜라

#### 선점, 비선점형 차이
* 비선점형: 프로세스가 자발적으로 blocking, exit 상태가 되어야만 다른 프로세스로 교체가 가능
* 선점형: 프로세스 running중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체 가능
* 현재의 시스템은 선점형 스케쥴러를 기본으로 하는것 같다.

#### 스케쥴러 구분
* fifo, sjf, priority based => 어떤 프로세스를 먼저 실행시킬것인지에 대한 알고리즘(비선점형 스케쥴링에 가깝다)
* Round Robin은 시분할 시스템을 위한 기본 알고리즘(선점형 스케쥴러)

# 인터럽트란
* cpu가 프로그램을 실행하고 있을때 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 cpu에 알려서 처리하는 기술(예외상황 발생시 알리미) 
* 막 집중하고 있을때 누가 말 걸거나 방해하면 (아 인터럽트좀 하지마!!)
* 인터럽트도 일종의 이벤트이다.

#### 인터럽트가 필요한 이유
* 선점형 스케쥴러에서 필요하다.
* 선점형 스케쥴러는 현재 실행중인 프로세스 실행을 중지시켜야 하는데 이때 인터럽트가 필요

# 인터럽트 종류
cpu는 결국 pc(program counter)가 가리키는 코드 1줄을 실행하는데만 집중하고 있다. 그래서 여러가지 외부에서 이벤트가 발생했을때 cpu에서 운영체제에 알려주기 위해 인터럽트가 등장했다.

#### 인터럽트 처리 예
* cpu가 프로그램을 실행하고 있을 때
  * 입출력 하드웨어 등의 장치 이슈 발생
    * 파일 처리가 끝났다는 것을 운영체제에 알려주기
    * 운영체제는 해당 프로세스를 block state에서 ready 상태로 상태 변경해주어야 한다.
* 또는 예외상황이 발생
  * 코드에서 0으로 나누는 것과 같은 예외상황이 발생했을때 운영체제에 알려주어야 한다.
  * 운영체제가 해당 프로세스 실행 중지/에러 표시

#### 이벤트와 인터럽트
* 인터럽트도 일종의 이벤트
* 운영체제에서 이벤트 발생시에 대한 응답이 정해져 있다.

인터럽트는 cpu에서 운영체제에 보내는 이벤트의 일종이구나!!!!


#### 주요 인터럽트
* 코드 실행중 예외상황 발생 인터럽트
* 타이머 인터럽트 => 하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려줌

#### 인터럽트 종류
* 내부 인터럽트
  * 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
    * 0으로 나눴을때
    * 사용자 모드에서 허용되지 않은 명령 또는 권한 접근시(커널 모드에서만 접근 가능한 명령을 실행할때)
    * 계산 결과가 overflow/underflow 날때(변수 타입 범위 넘어갈때)
    * 소프트웨어 인터럽트
* 외부 인터럽트
  * 주로 하드웨어에서 발생되는 이벤트
    * 전원 이상
    * 기계 문제
    * 키보드등 IO관련 이벤트
    * Timer 이벤트
    * 하드웨어 인터럽트

#### 시스템 콜 인터럽트
* 시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어서 cpu에게 실행시켜야 한다.
* 시스템콜도 인터럽트 였구나...
* 시스템 콜 실제 코드
  * eax 레지스터에 시스템 콜 번호를 넣고
  * ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고
  * 소프트웨어 인터럽트 명령을 호출하면서 0x80 값을 넘겨줌


```
  어셈블리어 예시
  mov eax. 1
  mov ebx, 0
  int 0x80 // 소프트웨어 인터럽트 명령
```

* 시스템콜 인터럽트 명령을 호출하면서 0x80값을 넘겨줌
  1. cpu는 사용자 모드를 커널 모드로 바꿔줌
  2. IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소를 찾아서 실행함
  3. system_call() 함수에서 eax 로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
  4. 해당 시스템콜 함수 실행 후, 다시 커널모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드 실행(pc에 있는 다음 코드 실행)

<img src="https://user-images.githubusercontent.com/72545732/142709692-5c9d7792-a556-4166-81d6-7c7f7d9716d3.png">

프로세스에서는 사용자 모드, 커널모드를 왔다갔다 하고 수시로 인터럽트도 발생하고 암튼 복잡하다, 시스템 콜은 인터럽트가 수반되어 동작한다.

#### 인터럽트와 IDT
* 인터럽트는 미리 정의되어 있는 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있음
  * where? IDT(Interrupt Descriptor Table)에 기록
  * when? 컴퓨터 부팅시 운영체제가 기록
  * what? 운영체제 내부 코드

* 리눅스의 예
  * 0 ~ 31 : 예외상황 인터럽트 (소프트웨어 인터럽트)
  * 32 ~ 47 : 하드웨어 인터럽트
  * 128 : 시스템 콜

1. 프로세스 실행 중 인터럽트 발생
2. 현 프로세스 실행 중단
3. 운영체제에서 인터럽트 처리 함수 실행
4. 현 프로세스 재실행


# 프로세스와 컨텍스트 스위칭

#### 프로세스와 컨텍스트 스위칭

* 프로세스의 구성
  * code : 코드
  * data : 변수/초기화된 데이터 
  * stack : 임시 데이터(함수 호출, 로컬 변수 등)
  * heap : 코드에서 동적으로 만들어지는 데이터
* PC(Program Counter) + SP(Stack Pointer)
  * PC : 다음 실행해야할 위치 가리키고 있음 (주소 레지스터)
  * SP : 함수가 실행될때 함수의 최상단 주소를 가리키고 있음

> Data를 BSS와 Data로 분리

* bss -> 초기화 되지 않은 전역변수
* data -> 초깃값이 있는 전역변수

```
int global_data1;  // bss
int global_data2 = 1; // data
```

#### 프로세스와 컨텍스트 스위칭

PCB(Process Control Block): 프로세스의 현재 상태를 가지고 있음

프로세스의 상태가 바뀌면 PCB내부 컨텍스트의 pc, stack pointer 값을 cpu내부의 레지스터에덮어 씌운다!!!!

PCB내부에 컨텍스트가 있음 컨텍스트 내부에 PC, StackPointer가 있음

<img src="https://user-images.githubusercontent.com/72545732/142712042-b76f53cc-7beb-42e5-ad96-b3fc9a20a4b0.png">

프로세스에서 스택은 아래로 증가하고 힙은 위로 증가한다.   
스택과 힙 사이에 여유공간이 있는데 이건 멀티 스레드 작업을 할 때 각 스레드 별로 영역을 나눠서 주어준다

<img src="https://user-images.githubusercontent.com/72545732/143032601-c024ec8a-ad98-4d3a-a3b0-d52a3a923c99.png">

#### PCB
* 구성
  * Process ID
  * Rgister 값(PC, SP등)
  * Scheduling Info(Process State)
  * Memory Info(메모리 사이즈 limit)

> PCB: 프로세스가 실행중인 상태를 캡쳐/구조화해서 저장

#### 프로세스와 컨텍스트 스위칭

* Context Switching(문맥 교환)
  * cpu에 실행할 프로세스를 교체하는 기술

1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트 해서, 메인 메모리에 저장
2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB정보를 cpu에 넣고 실행


#### 프로세스간 커뮤니케이션
- IPC(InterProcess Communication)
* 프로세스는 다른 프로세스의 공간을 접근할 수 없다.
* 다른 프로세스의 내부 정보를 변경하면 절대 안된다!!!(a프로세스가 b프로세스의 변수의 주소를 바꿔버리면 안된다)

프로세스 간 통신이 필요한 이유
* 성능을 높이기 위해 여러 프로세스로 동시에 실행
* 이때 프로세스간 통신 필요

저장 매체는 공유 가능, 파일에 저장하면 공유가 가능하긴 한데 -> 계속 실시간으로 읽고만 있을순 없다.
IPC 기법
1. 파일 사용(1개의 파일에 저장 및 불러오기)
2. Message Queue
3. Shared Memory(메모리 공간에 대한 주소값을 가지고 변수처럼 쓸 수 있다.)
4. Pipe(단방향 통신)
5. Signal
6. Semaphore
7. Socker

2~7번은 전부 커널 모드에 있는걸 사용하기 위한거다. 커널모드는 프로세스들끼리 같은 공간을 공유한다!!!

#### 시그널 

* 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법
* 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 수행
  * 시그널 무시
  * 시그널 블록(블록을 푸는 순간, 프로세스에 해당 시그널 전달)
  * 등록된 시그널 핸들러로 특정 동작 수행
  * 등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행

#### 소켓
<img src="https://user-images.githubusercontent.com/72545732/143022027-d790bd87-c8a9-47c5-8841-2c72d616eeb4.png">


### 프로세스 총정리
빈번한 IO 처리는 시간이 많이 필요하게 된다
